---
title: "Nature of Reasonableness Analysis"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 5
    df_print: paged
  pdf_document: default
---

This is the formal analysis file for the "The Nature of Reasonableness" by by Kevin Tobia, Ivar R. Hannikainen, David Kamper, Guilherme Almeida, Piotr Bystranowski, Niek Strohmaier, Vilius Dranseika, Markus Kneer, Fernando Aguiar, Kristina Dolinina, Bartosz Janik, Eglė Lauraitytė, Alice Liefgreen, Maciej Próchnicki, Alejandro Rosas, Vivek Kumar Shukla, and Noel Struchiner (2025, Stanford Journal of International Law).

## Introduction and Loading of Files

```{r}
# Load Libraries

library(dplyr)
library(tidyverse)
library(stats)
library(ggplot2)
library(ggthemes)
library(corrplot)
library(gridExtra)
library(kableExtra)
library(effects)
```

```{r}
DATA_PATH <- "/Users/dgkamper/Library/CloudStorage/GoogleDrive-dgkamper@gmail.com/My Drive/DGK Lab/Collaborations/Language and Law Laboratory/Analysis/LegalResonablenessAnalysis/Data_all_numeric.csv"
```

#### Initial Data Loading and Preparation

```{r}
# Read the data from specified path
Data_All <- read.csv(DATA_PATH, stringsAsFactors = FALSE)

# Verify data structure
glimpse(Data_All)
```

#### Exclude participants whose answer to Q19 does not equal 15 [comprehension/attention question].

```{r}
# Split data by condition
Data_All_Average <- Data_All %>% filter(Condition_name == "Average")
Data_All_Ideal <- Data_All %>% filter(Condition_name == "Ideal")
Data_All_Reasonable <- Data_All %>% filter(Condition_name == "Reasonable")

# Exclude participants whose answer to Q19 does not equal 15 [comprehension/attention question].
Data_All_Average_Pass1 <- Data_All_Average %>% filter(q19 == 15)
Data_All_Ideal_Pass1 <- Data_All_Ideal %>% filter(q19 == 15)
Data_All_Reasonable_Pass1 <- Data_All_Reasonable %>% filter(q19 == 15)

# Print participant counts
condition_counts <- data.frame(
  Condition = c("Average", "Ideal", "Reasonable"),
  Original_Count = c(nrow(Data_All_Average), nrow(Data_All_Ideal), nrow(Data_All_Reasonable)),
  After_Attention_Check = c(nrow(Data_All_Average_Pass1), nrow(Data_All_Ideal_Pass1), nrow(Data_All_Reasonable_Pass1)),
  Excluded_Count = c(nrow(Data_All_Average) - nrow(Data_All_Average_Pass1), 
                     nrow(Data_All_Ideal) - nrow(Data_All_Ideal_Pass1),
                     nrow(Data_All_Reasonable) - nrow(Data_All_Reasonable_Pass1)),
  Exclusion_Rate = c((nrow(Data_All_Average) - nrow(Data_All_Average_Pass1))/nrow(Data_All_Average),
                     (nrow(Data_All_Ideal) - nrow(Data_All_Ideal_Pass1))/nrow(Data_All_Ideal),
                     (nrow(Data_All_Reasonable) - nrow(Data_All_Reasonable_Pass1))/nrow(Data_All_Reasonable))
)

# Format the exclusion rate as percentage
condition_counts$Exclusion_Rate <- scales::percent(condition_counts$Exclusion_Rate)

# Display the participant counts table
kable(condition_counts, caption = "Participant Counts Before and After Attention Check") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = F)
```

```{r}
# Define the question columns - ensuring they actually exist in the data
question_cols <- c("q1", "q2", "q3", "q4", "m", "q6", "q7", "q8", "q9", "q10", 
                  "q11", "q12", "q13", "q14", "q15", "q16", "q17", "q18", 
                  "q20", "q21", "q22", "q23", "q24", "q25", "q26", "q27", 
                  "q28", "q29", "q30", "q31", "q32", "q33", "q34")

# Check if all question columns exist in the data
existing_cols <- question_cols[question_cols %in% colnames(Data_All_Average_Pass1)]
missing_cols <- question_cols[!question_cols %in% colnames(Data_All_Average_Pass1)]

print("Existing question columns:")
print(existing_cols)
print("Missing question columns:")
print(missing_cols)
```
#### Check Number of Participants per Condition 

```{r}
# Continue with only the existing columns
question_cols <- existing_cols

# Convert columns to numeric - using a safer approach
Data_All_Average_Pass1 <- Data_All_Average_Pass1 %>%
  mutate(across(all_of(question_cols), ~as.numeric(as.character(.))))

Data_All_Ideal_Pass1 <- Data_All_Ideal_Pass1 %>%
  mutate(across(all_of(question_cols), ~as.numeric(as.character(.))))

Data_All_Reasonable_Pass1 <- Data_All_Reasonable_Pass1 %>%
  mutate(across(all_of(question_cols), ~as.numeric(as.character(.))))

# Verify the number of participants in each condition
cat("Ideal condition:", nrow(Data_All_Ideal_Pass1), "participants\n")
cat("Average condition:", nrow(Data_All_Average_Pass1), "participants\n")
cat("Reasonable condition:", nrow(Data_All_Reasonable_Pass1), "participants\n")
```

# Analysis 1: Overall results, mean ratings [following Bear & Knobe 2016]

#### Compute the mean rating and filter data

For any response that is greater than 3 standard deviations from that question mean, exclude that response.

```{r}
# Function to filter data based on 3 SD criterion
filter_data <- function(data, cols) {
  # Pre-allocate a list to track excluded participants for each question
  exclusions_by_question <- list()
  
  # Original count
  original_count <- nrow(data)
  
  result <- data
  for (col in cols) {
    if (col %in% colnames(data)) {
      # Calculate mean and standard deviation
      avg <- mean(result[[col]], na.rm = TRUE)
      s <- sd(result[[col]], na.rm = TRUE)
      
      # Identify outliers
      outlier_indices <- which(!is.na(result[[col]]) & abs(result[[col]] - avg) > 3 * s)
      exclusions_by_question[[col]] <- length(outlier_indices)
      
      # Filter out outliers
      result <- result %>%
        filter(is.na(!!sym(col)) | abs(!!sym(col) - avg) <= 3 * s)
    }
  }
  
  # Final count
  final_count <- nrow(result)
  
  return(list(
    filtered_data = result,
    original_count = original_count,
    final_count = final_count,
    excluded_count = original_count - final_count,
    exclusion_rate = (original_count - final_count) / original_count,
    exclusions_by_question = exclusions_by_question
  ))
}

# Apply filtering and track exclusion counts
avg_filter_results <- filter_data(Data_All_Average_Pass1, question_cols)
ideal_filter_results <- filter_data(Data_All_Ideal_Pass1, question_cols)
reasonable_filter_results <- filter_data(Data_All_Reasonable_Pass1, question_cols)

# Display outlier exclusion summary
outlier_summary <- data.frame(
  Condition = c("Average", "Ideal", "Reasonable"),
  Original_Count = c(avg_filter_results$original_count, 
                    ideal_filter_results$original_count, 
                    reasonable_filter_results$original_count),
  After_Outlier_Removal = c(avg_filter_results$final_count, 
                           ideal_filter_results$final_count, 
                           reasonable_filter_results$final_count),
  Excluded_Count = c(avg_filter_results$excluded_count, 
                    ideal_filter_results$excluded_count, 
                    reasonable_filter_results$excluded_count),
  Exclusion_Rate = c(avg_filter_results$exclusion_rate,
                    ideal_filter_results$exclusion_rate,
                    reasonable_filter_results$exclusion_rate)
)

# Format the exclusion rate as percentage
outlier_summary$Exclusion_Rate <- scales::percent(outlier_summary$Exclusion_Rate)

# Display the outlier exclusion summary table
kable(outlier_summary, caption = "Participant Counts Before and After Outlier Removal") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = F)
```

```{r}
# Extract the filtered data
Data_All_Average_Filtered <- avg_filter_results$filtered_data
Data_All_Ideal_Filtered <- ideal_filter_results$filtered_data
Data_All_Reasonable_Filtered <- reasonable_filter_results$filtered_data

# Calculate means after excluding outliers
filtered_column_means_average <- sapply(Data_All_Average_Filtered[, question_cols], mean, na.rm = TRUE)
filtered_column_means_ideal <- sapply(Data_All_Ideal_Filtered[, question_cols], mean, na.rm = TRUE)
filtered_column_means_reasonable <- sapply(Data_All_Reasonable_Filtered[, question_cols], mean, na.rm = TRUE)

# Create a dataframe for the means
means_df <- data.frame(
  Question = names(filtered_column_means_average),
  Average = filtered_column_means_average,
  Ideal = filtered_column_means_ideal,
  Reasonable = filtered_column_means_reasonable
)

# Display the means for each question
kable(means_df, caption = "Mean Values for Each Question by Condition") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = F)

# Create a comparison table of means for plotting
means_long <- means_df %>%
  pivot_longer(cols = c(Average, Ideal, Reasonable), 
               names_to = "Condition", 
               values_to = "Mean")
```

#### Convert mean responses to a natural log scale.

```{r}
## Convert mean responses to a natural log scale.
log_filtered_column_means_average <- log(filtered_column_means_average)
log_filtered_column_means_ideal <- log(filtered_column_means_ideal)
log_filtered_column_means_reasonable <- log(filtered_column_means_reasonable)

# Check if we have any zeros before taking logs
print("Checking for zeros in means:")
print("Zeros in average means:")
print(names(filtered_column_means_average[filtered_column_means_average == 0]))
print("Zeros in ideal means:")
print(names(filtered_column_means_ideal[filtered_column_means_ideal == 0]))
print("Zeros in reasonable means:")
print(names(filtered_column_means_reasonable[filtered_column_means_reasonable == 0]))
```
#### Convert mean responses to a natural log scale (done more safely accounting zeros in reasonable means)

```{r}
safe_log <- function(x) {
  # Replace zeros with a small constant
  x[x == 0] <- 0.01
  log(x)
}

# Take logs 
log_filtered_column_means_average <- safe_log(filtered_column_means_average)
log_filtered_column_means_ideal <- safe_log(filtered_column_means_ideal)
log_filtered_column_means_reasonable <- safe_log(filtered_column_means_reasonable)

# Create a dataframe for the log means
log_means_df <- data.frame(
  Question = names(log_filtered_column_means_average),
  Average = log_filtered_column_means_average,
  Ideal = log_filtered_column_means_ideal,
  Reasonable = log_filtered_column_means_reasonable
)
```

#### Conduct three regressions and record AIC

```{r}
# Prepare data for regression
dataforAICMeans <- data.frame(
  Reasonable = log_filtered_column_means_reasonable,
  Average = log_filtered_column_means_average,
  Ideal = log_filtered_column_means_ideal
)

# Model I: Average predicts reasonable
Model1Means <- lm(Reasonable ~ Average, data = dataforAICMeans)
AIC1Means <- AIC(Model1Means)
r2_model1 <- summary(Model1Means)$r.squared

# Model II: Ideal predicts reasonable
Model2Means <- lm(Reasonable ~ Ideal, data = dataforAICMeans)
AIC2Means <- AIC(Model2Means)
r2_model2 <- summary(Model2Means)$r.squared

# Model III: Both average and ideal predict reasonable
Model3Means <- lm(Reasonable ~ Average + Ideal, data = dataforAICMeans)
AIC3Means <- AIC(Model3Means)
r2_model3 <- summary(Model3Means)$r.squared

# Create a regression summary dataframe
regression_summary <- data.frame(
  Model = c("Average predicts Reasonable", 
            "Ideal predicts Reasonable", 
            "Average + Ideal predict Reasonable"),
  AIC = c(AIC1Means, AIC2Means, AIC3Means),
  R_squared = c(r2_model1, r2_model2, r2_model3)
)

# Display the regression summary table
kable(regression_summary, caption = "Regression Model Comparison") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = F)
```

#### Plots and Reporting

```{r}
# Identify the best model based on AIC
best_model <- which.min(c(AIC1Means, AIC2Means, AIC3Means))
best_model_name <- c("Average → Reasonable", "Ideal → Reasonable", "Hybrid Model")[best_model]

# Create separate plots for Model 1 and Model 2
plot1 <- ggplot(dataforAICMeans, aes(x = Average, y = Reasonable)) +
  geom_point(size = 3, alpha = 0.7) +
  geom_smooth(method = "lm", se = TRUE, color = "blue") +
  labs(title = "Model 1: Average Predicts Reasonable",
       subtitle = paste("AIC =", round(AIC1Means, 2), ", R² =", round(r2_model1, 3)),
       x = "Log Average Rating",
       y = "Log Reasonable Rating") +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 12)
  )

plot2 <- ggplot(dataforAICMeans, aes(x = Ideal, y = Reasonable)) +
  geom_point(size = 3, alpha = 0.7) +
  geom_smooth(method = "lm", se = TRUE, color = "red") +
  labs(title = "Model 2: Ideal Predicts Reasonable",
       subtitle = paste("AIC =", round(AIC2Means, 2), ", R² =", round(r2_model2, 3)),
       x = "Log Ideal Rating",
       y = "Log Reasonable Rating") +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 12)
  )

# Create Model 3 visualization - effects of Average while holding Ideal constant
new_data <- expand.grid(
  Average = seq(min(dataforAICMeans$Average), max(dataforAICMeans$Average), length.out = 100),
  Ideal = median(dataforAICMeans$Ideal)  # Hold Ideal constant at median
)
new_data$predicted_reasonable <- predict(Model3Means, newdata = new_data)

plot3 <- ggplot(dataforAICMeans, aes(x = Average, y = Reasonable)) +
  geom_point(size = 3, alpha = 0.5) +
  geom_line(data = new_data, aes(y = predicted_reasonable), color = "blue", size = 1) +
  labs(title = "Model 3: Effect of Average",
       subtitle = "Controlling for Ideal (held at median)",
       x = "Log Average Rating",
       y = "Log Reasonable Rating") +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 12)
  )

# Create Model 3 visualization - effects of Ideal while holding Average constant
new_data2 <- expand.grid(
  Average = median(dataforAICMeans$Average),  # Hold Average constant at median
  Ideal = seq(min(dataforAICMeans$Ideal), max(dataforAICMeans$Ideal), length.out = 100)
)
new_data2$predicted_reasonable <- predict(Model3Means, newdata = new_data2)

plot4 <- ggplot(dataforAICMeans, aes(x = Ideal, y = Reasonable)) +
  geom_point(size = 3, alpha = 0.5) +
  geom_line(data = new_data2, aes(y = predicted_reasonable), color = "red", size = 1) +
  labs(title = "Model 3: Effect of Ideal",
       subtitle = "Controlling for Average (held at median)",
       x = "Log Ideal Rating",
       y = "Log Reasonable Rating") +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 12)
  )

# Display plots individually 
print(plot1)
print(plot2)
print(plot3)
print(plot4)

# Create an explanatory figure showing the relationship between means
means_summary <- data.frame(
  Question = 1:length(filtered_column_means_average),
  Average = filtered_column_means_average,
  Ideal = filtered_column_means_ideal,
  Reasonable = filtered_column_means_reasonable
) %>%
  # Take a subset of questions for clearer visualization
  slice(1:10)

# Convert to long format for plotting
means_summary_long <- means_summary %>%
  pivot_longer(cols = c(Average, Ideal, Reasonable),
               names_to = "Rating_Type",
               values_to = "Value") %>%
  mutate(Rating_Type = factor(Rating_Type, levels = c("Average", "Reasonable", "Ideal")))

# Create an explanatory plot
explanatory_plot <- ggplot(means_summary_long, aes(x = Rating_Type, y = Value, group = Question, color = factor(Question))) +
  geom_line(size = 1) +
  geom_point(size = 3) +
  labs(title = "Relationship Between Average, Reasonable, and Ideal Ratings",
       subtitle = "Example of first 10 questions showing how Reasonable often falls between Average and Ideal",
       x = "Rating Type",
       y = "Value",
       color = "Question") +
  theme_minimal() +
  theme(
    legend.position = "none",
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 12)
  )

# Display and save the explanatory plot
print(explanatory_plot)
ggsave("reasonable_between_average_ideal.png", explanatory_plot, width = 8, height = 6, dpi = 300)

# Create table of model coefficients
get_model_coefs <- function(model) {
  coefs <- summary(model)$coefficients
  data.frame(
    Term = rownames(coefs),
    Estimate = coefs[,1],
    Std_Error = coefs[,2],
    t_value = coefs[,3],
    p_value = coefs[,4]
  )
}

# Format p-values with asterisks for significance levels
format_pvalue <- function(p) {
  if (p < 0.001) return("< 0.001 ***")
  if (p < 0.01) return(paste0(round(p, 3), " **"))
  if (p < 0.05) return(paste0(round(p, 3), " *"))
  return(as.character(round(p, 3)))
}

# Get and format model coefficients
model3_coefs <- get_model_coefs(Model3Means)
model3_coefs$p_value <- sapply(model3_coefs$p_value, format_pvalue)

# Display the hybrid model coefficients
kable(model3_coefs, caption = "Hybrid Model Coefficients (Average + Ideal → Reasonable)") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = F)

# Store analysis results (simplified)
analysis_1_results <- list(
  regression_models = list(
    model1 = Model1Means,
    model2 = Model2Means,
    model3 = Model3Means
  ),
  regression_summary = regression_summary,
  aic_values = c(AIC1 = AIC1Means, AIC2 = AIC2Means, AIC3 = AIC3Means)
)
```

# Analysis 2: Overall results, intermediacy [following Bear & Knobe 2016]

#### Determine if each mean reasonableness rating is on the "ideal side" of average. 

```{r}
# Function to check if reasonable is on the "ideal side" of average.
# That is, if the reasonable rating is as close or closer to the ideal than to the average.
is_ideal_side <- function(average, ideal, reasonable) {
  ifelse(abs(reasonable - ideal) <= abs(reasonable - average), 1, 0)
}

# Apply the function to raw means
ideal_side_vector <- mapply(is_ideal_side,
                           filtered_column_means_average,
                           filtered_column_means_ideal,
                           filtered_column_means_reasonable)

# Apply the function to log-transformed means
ideal_side_vector_log <- mapply(is_ideal_side,
                               log_filtered_column_means_average,
                               log_filtered_column_means_ideal,
                               log_filtered_column_means_reasonable)

# Count how many questions have reasonableness on the "ideal side" of average
count_ideal_side <- sum(ideal_side_vector)
count_ideal_side_log <- sum(ideal_side_vector_log)

# Conduct binomial tests to assess whether the proportion is greater than 50%
binomial_result_ideal <- binom.test(count_ideal_side, length(question_cols), p = 0.5, 
                                   alternative = "greater")
binomial_result_ideal_log <- binom.test(count_ideal_side_log, length(question_cols), p = 0.5, 
                                      alternative = "greater")

# Create a summary table for the binomial test results
ideal_side_summary <- data.frame(
  Data_Type = c("Raw Means", "Log Means"),
  On_Ideal_Side_Count = c(count_ideal_side, count_ideal_side_log),
  Total_Questions = c(length(question_cols), length(question_cols)),
  Proportion = c(count_ideal_side/length(question_cols), 
                count_ideal_side_log/length(question_cols)),
  p_value = c(binomial_result_ideal$p.value, binomial_result_ideal_log$p.value)
)

# Format proportions and p-values for display
ideal_side_summary$Proportion <- scales::percent(ideal_side_summary$Proportion)
ideal_side_summary$p_value <- sapply(ideal_side_summary$p_value, format_pvalue)

# Display the binomial test results table
kable(ideal_side_summary, 
      caption = "Binomial Test Results: Is Reasonableness on the Ideal Side of Average?") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = F)

```

#### Determine if each mean reasonableness rating is on the "average side" of ideal. 

```{r}
# Function to check if reasonable is on the "average side" of ideal.
# That is, if the reasonable rating is as close or closer to the average than to the ideal.
is_average_side <- function(average, ideal, reasonable) {
  ifelse(abs(reasonable - average) <= abs(reasonable - ideal), 1, 0)
}

# Apply the function to raw means
average_side_vector <- mapply(is_average_side,
                             filtered_column_means_average,
                             filtered_column_means_ideal,
                             filtered_column_means_reasonable)

# Apply the function to log-transformed means
average_side_vector_log <- mapply(is_average_side,
                                 log_filtered_column_means_average,
                                 log_filtered_column_means_ideal,
                                 log_filtered_column_means_reasonable)

# Count how many questions have reasonableness on the "average side" of ideal
count_average_side <- sum(average_side_vector)
count_average_side_log <- sum(average_side_vector_log)

# Conduct binomial tests to assess whether the proportion is greater than 50%
binomial_result_avg_side <- binom.test(count_average_side, length(question_cols), p = 0.5, 
                                      alternative = "greater")
binomial_result_avg_side_log <- binom.test(count_average_side_log, length(question_cols), p = 0.5, 
                                         alternative = "greater")

# Create a summary table for the binomial test results
average_side_summary <- data.frame(
  Data_Type = c("Raw Means", "Log Means"),
  On_Average_Side_Count = c(count_average_side, count_average_side_log),
  Total_Questions = c(length(question_cols), length(question_cols)),
  Proportion = c(count_average_side/length(question_cols), 
                count_average_side_log/length(question_cols)),
  p_value = c(binomial_result_avg_side$p.value, binomial_result_avg_side_log$p.value)
)

# Format proportions and p-values for display
average_side_summary$Proportion <- scales::percent(average_side_summary$Proportion)
average_side_summary$p_value <- sapply(average_side_summary$p_value, format_pvalue)

# Display the binomial test results table
kable(average_side_summary, 
      caption = "Binomial Test Results: Is Reasonableness on the Average Side of Ideal?") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = F)


```

#### Determine if reasonableness is BOTH on the ideal side of average AND on the average side of ideal.

```{r}
# Function to check if reasonable falls between average and ideal.
# This is a robust check: if (reasonable - average) and (reasonable - ideal) have opposite signs or are zero,
# then reasonable is between (or equal to one of) the anchors.
is_both_sides <- function(average, ideal, reasonable) {
  ifelse((reasonable - average) * (reasonable - ideal) <= 0, 1, 0)
}

# Apply the function to raw means
both_sides_vector <- mapply(is_both_sides,
                           filtered_column_means_average,
                           filtered_column_means_ideal,
                           filtered_column_means_reasonable)

# Apply the function to log-transformed means
both_sides_vector_log <- mapply(is_both_sides,
                               log_filtered_column_means_average,
                               log_filtered_column_means_ideal,
                               log_filtered_column_means_reasonable)

# Count how many questions have reasonableness on both sides
count_both_sides <- sum(both_sides_vector)
count_both_sides_log <- sum(both_sides_vector_log)

# Conduct binomial tests with 1/3 as the chance rate (as specified in the analysis plan)
binomial_result_both_sides <- binom.test(count_both_sides, length(question_cols), p = 1/3, 
                                        alternative = "two.sided")
binomial_result_both_sides_log <- binom.test(count_both_sides_log, length(question_cols), p = 1/3, 
                                           alternative = "two.sided")

# Create a summary table for the binomial test results
both_sides_summary <- data.frame(
  Data_Type = c("Raw Means", "Log Means"),
  On_Both_Sides_Count = c(count_both_sides, count_both_sides_log),
  Total_Questions = c(length(question_cols), length(question_cols)),
  Proportion = c(count_both_sides/length(question_cols), 
                count_both_sides_log/length(question_cols)),
  Expected_Chance = c(1/3, 1/3),
  p_value = c(binomial_result_both_sides$p.value, binomial_result_both_sides_log$p.value)
)

# Format proportions and p-values for display
both_sides_summary$Proportion <- scales::percent(both_sides_summary$Proportion)
both_sides_summary$Expected_Chance <- scales::percent(both_sides_summary$Expected_Chance)
both_sides_summary$p_value <- sapply(both_sides_summary$p_value, format_pvalue)

# Display the binomial test results table
kable(both_sides_summary, 
      caption = "Binomial Test Results: Is Reasonableness Between Average and Ideal?") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = F)

```

#### Plots and Reporting

```{r}
# Create a table showing the results for each question
question_position_summary <- data.frame(
  Question = names(filtered_column_means_average),
  Average_Value = filtered_column_means_average,
  Ideal_Value = filtered_column_means_ideal,
  Reasonable_Value = filtered_column_means_reasonable,
  On_Ideal_Side = ideal_side_vector,
  On_Average_Side = average_side_vector,
  Between_Average_And_Ideal = both_sides_vector
)

# Categorize each question's position
question_position_summary$Position <- "Other"
question_position_summary$Position[question_position_summary$Between_Average_And_Ideal == 1] <- "Between Average and Ideal"
question_position_summary$Position[question_position_summary$On_Ideal_Side == 1 & 
                                  question_position_summary$On_Average_Side == 0] <- "Beyond Ideal"
question_position_summary$Position[question_position_summary$On_Ideal_Side == 0 & 
                                  question_position_summary$On_Average_Side == 1] <- "Beyond Average"

# Display the question position summary
kable(question_position_summary[, c("Question", "Average_Value", "Ideal_Value", "Reasonable_Value", "Position")], 
      caption = "Position of Reasonable Rating Relative to Average and Ideal for Each Question") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = F)

# Count the number of questions in each position category
position_counts <- table(question_position_summary$Position)

# Create a data frame for the position summary
position_summary <- data.frame(
  Position = names(position_counts),
  Count = as.numeric(position_counts)
)

# Calculate the percentages manually to ensure they're numeric
position_summary$Percentage <- (position_summary$Count / sum(position_summary$Count)) * 100

# Round the percentages to one decimal place
position_summary$Percentage <- round(position_summary$Percentage, 1)

# Display the position count summary
kable(position_summary, 
      caption = "Distribution of Position Categories") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = F)

# Create a visualization showing the distribution of positions
ggplot(position_summary, aes(x = Position, y = Count, fill = Position)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = paste0(Count, " (", Percentage, "%)")), 
            vjust = -0.5, size = 4) +
  labs(title = "Distribution of Position Categories",
       subtitle = "Where does 'Reasonable' fall relative to 'Average' and 'Ideal'?",
       x = "Position Category",
       y = "Number of Questions") +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 12),
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 10),
    legend.position = "none"
  )

# Save the position distribution plot
ggsave("position_distribution.png", width = 10, height = 6, dpi = 300)

# Create a triangle visualization to show the relationships between the ratings
# Prepare data for the triangle visualization
triangle_data <- question_position_summary

# Create a function to normalize values to 0-1 scale for better visualization
normalize <- function(x) {
  (x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE))
}

# Create a scatterplot showing the relative positions
ggplot(triangle_data, aes(x = Average_Value, y = Ideal_Value)) +
  # Add a diagonal reference line where average = ideal
  geom_abline(intercept = 0, slope = 1, linetype = "dashed", alpha = 0.5) +
  # Add points for each question's average and ideal values
  geom_point(color = "gray60", size = 3, alpha = 0.6) +
  # Add points for reasonable values, colored by position category
  geom_point(aes(x = Average_Value, y = Reasonable_Value, color = Position), size = 4) +
  # Connect reasonable to average with a line
  geom_segment(aes(xend = Average_Value, yend = Reasonable_Value, color = Position), 
               linetype = "dotted", size = 0.5) +
  # geom_text(aes(label = Question), hjust = -0.2, vjust = 0, size = 3) +
  scale_color_brewer(palette = "Set1") +
  labs(title = "Intermediacy Analysis: Position of Reasonable Relative to Average and Ideal",
       subtitle = paste0("Questions with Reasonable between Average and Ideal: ", 
                         count_both_sides, " of ", length(question_cols), 
                         " (", scales::percent(count_both_sides/length(question_cols)), ")"),
       x = "Average Rating",
       y = "Rating Value",
       color = "Position Category") +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 12),
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 10),
    legend.position = "bottom"
  )

# Save the intermediacy plot
ggsave("intermediacy_analysis.png", width = 10, height = 8, dpi = 300)

# Create a more detailed plot showing all three ratings for each question
# Convert to long format for plotting
ratings_long <- triangle_data %>%
  select(Question, Average_Value, Ideal_Value, Reasonable_Value, Position) %>%
  pivot_longer(cols = c(Average_Value, Ideal_Value, Reasonable_Value),
               names_to = "Rating_Type",
               values_to = "Value") %>%
  mutate(Rating_Type = gsub("_Value", "", Rating_Type))

# Plot the ratings for each question, grouped and colored
ggplot(ratings_long, aes(x = Rating_Type, y = Value, group = Question, color = Position)) +
  geom_line(alpha = 0.6) +
  geom_point(size = 3) +
  facet_wrap(~ Position, scales = "free_y") +
  scale_color_brewer(palette = "Set1") +
  labs(title = "Rating Patterns by Position Category",
       subtitle = "How Average, Ideal, and Reasonable ratings relate within each position category",
       x = "Rating Type",
       y = "Value") +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 12),
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 10),
    legend.position = "none"
  )

# Save the ratings pattern plot
ggsave("rating_patterns_by_position.png", width = 12, height = 8, dpi = 300)

# Store all the results in a structured list
analysis_2_results <- list(
  ideal_side = list(
    vector = ideal_side_vector,
    log_vector = ideal_side_vector_log,
    count = count_ideal_side,
    log_count = count_ideal_side_log,
    binomial_test = binomial_result_ideal,
    log_binomial_test = binomial_result_ideal_log,
    summary = ideal_side_summary
  ),
  average_side = list(
    vector = average_side_vector,
    log_vector = average_side_vector_log,
    count = count_average_side,
    log_count = count_average_side_log,
    binomial_test = binomial_result_avg_side,
    log_binomial_test = binomial_result_avg_side_log,
    summary = average_side_summary
  ),
  both_sides = list(
    vector = both_sides_vector,
    log_vector = both_sides_vector_log,
    count = count_both_sides,
    log_count = count_both_sides_log,
    binomial_test = binomial_result_both_sides,
    log_binomial_test = binomial_result_both_sides_log,
    summary = both_sides_summary
  ),
  question_position = question_position_summary,
  position_summary = position_summary
)
```
# Analysis 3: Overall results, with median ratings

Exclude participants whose answer to Q19 does not equal 15 [comprehension/attention question]. [THIS HAS BEEN COMPLETED IN ANALYSIS 1]

#### Compute the median rating

```{r}
# Calculate medians directly from the attention-check filtered data
column_medians_average <- sapply(Data_All_Average_Pass1[, question_cols], median, na.rm = TRUE)
column_medians_ideal <- sapply(Data_All_Ideal_Pass1[, question_cols], median, na.rm = TRUE)
column_medians_reasonable <- sapply(Data_All_Reasonable_Pass1[, question_cols], median, na.rm = TRUE)

# Create a dataframe for the medians
medians_df <- data.frame(
  Question = names(column_medians_average),
  Average = column_medians_average,
  Ideal = column_medians_ideal,
  Reasonable = column_medians_reasonable
)

# Display the medians for each question
kable(medians_df, caption = "Median Values for Each Question by Condition") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = F)

# Create a comparison table of medians for plotting
medians_long <- medians_df %>%
  pivot_longer(cols = c(Average, Ideal, Reasonable), 
               names_to = "Condition", 
               values_to = "Median")
```

#### Convert median responses to a natural log scale

```{r}
# Check if we have any zeros in medians before taking logs
print("Checking for zeros in medians:")
print("Zeros in average medians:")
print(names(column_medians_average[column_medians_average == 0]))
print("Zeros in ideal medians:")
print(names(column_medians_ideal[column_medians_ideal == 0]))
print("Zeros in reasonable medians:")
print(names(column_medians_reasonable[column_medians_reasonable == 0]))

# Apply the same safe_log function used in Analysis 1
log_filtered_column_medians_average <- safe_log(column_medians_average)
log_filtered_column_medians_ideal <- safe_log(column_medians_ideal)
log_filtered_column_medians_reasonable <- safe_log(column_medians_reasonable)

# Create a dataframe for the log medians
log_medians_df <- data.frame(
  Question = names(log_filtered_column_medians_average),
  Average = log_filtered_column_medians_average,
  Ideal = log_filtered_column_medians_ideal,
  Reasonable = log_filtered_column_medians_reasonable
)

# Display the log medians
kable(log_medians_df, caption = "Log-Transformed Median Values for Each Question by Condition") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = F)
```

#### Conduct three regressions and record AIC

```{r}
# Create data frame for regression
dataforAICMedians <- data.frame(
  Reasonable = log_filtered_column_medians_reasonable,
  Average = log_filtered_column_medians_average,
  Ideal = log_filtered_column_medians_ideal
)

# Model I: Median Average predicts Median Reasonable
Model1Medians <- lm(Reasonable ~ Average, data = dataforAICMedians)
AIC1Medians <- AIC(Model1Medians)
r2_model1_median <- summary(Model1Medians)$r.squared

# Model II: Median Ideal predicts Median Reasonable
Model2Medians <- lm(Reasonable ~ Ideal, data = dataforAICMedians)
AIC2Medians <- AIC(Model2Medians)
r2_model2_median <- summary(Model2Medians)$r.squared

# Model III: Both Median Average and Median Ideal predict Median Reasonable
Model3Medians <- lm(Reasonable ~ Average + Ideal, data = dataforAICMedians)
AIC3Medians <- AIC(Model3Medians)
r2_model3_median <- summary(Model3Medians)$r.squared

# Create a regression summary dataframe
regression_summary_medians <- data.frame(
  Model = c("Average predicts Reasonable", 
            "Ideal predicts Reasonable", 
            "Average + Ideal predict Reasonable"),
  AIC = c(AIC1Medians, AIC2Medians, AIC3Medians),
  R_squared = c(r2_model1_median, r2_model2_median, r2_model3_median)
)

# Display the regression summary table
kable(regression_summary_medians, caption = "Regression Model Comparison (Median Values)") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = F)
```

#### Plots and Reporting

```{r}
# Average Median vs Reasonable Median
plot1_median <- ggplot(dataforAICMedians, aes(x = Average, y = Reasonable)) +
  geom_point(size = 3, alpha = 0.7) +
  geom_smooth(method = "lm", se = TRUE, color = "blue") +
  labs(title = "Model 1: Median Average Predicts Median Reasonable",
       subtitle = paste("AIC =", round(AIC1Medians, 2), ", R² =", round(r2_model1_median, 3)),
       x = "Log Median Average Rating",
       y = "Log Median Reasonable Rating") +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 12),
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 10)
  )

# Ideal Median vs Reasonable Median
plot2_median <- ggplot(dataforAICMedians, aes(x = Ideal, y = Reasonable)) +
  geom_point(size = 3, alpha = 0.7) +
  geom_smooth(method = "lm", se = TRUE, color = "red") +
  labs(title = "Model 2: Median Ideal Predicts Median Reasonable",
       subtitle = paste("AIC =", round(AIC2Medians, 2), ", R² =", round(r2_model2_median, 3)),
       x = "Log Median Ideal Rating",
       y = "Log Median Reasonable Rating") +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 12),
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 10)
  )

# Create Model 3 visualizations for median-based analysis
# Model 3 visualization (effect of average, holding ideal constant)
new_data_median <- expand.grid(
  Average = seq(min(dataforAICMedians$Average), max(dataforAICMedians$Average), length.out = 100),
  Ideal = median(dataforAICMedians$Ideal)  # Hold Ideal constant at median
)
new_data_median$predicted_reasonable <- predict(Model3Medians, newdata = new_data_median)

plot3_median <- ggplot(dataforAICMedians, aes(x = Average, y = Reasonable)) +
  geom_point(size = 3, alpha = 0.5) +
  geom_line(data = new_data_median, aes(y = predicted_reasonable), color = "blue", size = 1) +
  labs(title = "Model 3: Effect of Median Average (Holding Median Ideal at Median)",
       subtitle = paste("AIC =", round(AIC3Medians, 2), ", R² =", round(r2_model3_median, 3)),
       x = "Log Median Average Rating",
       y = "Log Median Reasonable Rating") +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 12),
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 10)
  )

# Model 3 visualization (effect of ideal, holding average constant)
new_data2_median <- expand.grid(
  Average = median(dataforAICMedians$Average),  # Hold Average constant at median
  Ideal = seq(min(dataforAICMedians$Ideal), max(dataforAICMedians$Ideal), length.out = 100)
)
new_data2_median$predicted_reasonable <- predict(Model3Medians, newdata = new_data2_median)

plot4_median <- ggplot(dataforAICMedians, aes(x = Ideal, y = Reasonable)) +
  geom_point(size = 3, alpha = 0.5) +
  geom_line(data = new_data2_median, aes(y = predicted_reasonable), color = "red", size = 1) +
  labs(title = "Model 3: Effect of Median Ideal (Holding Median Average at Median)",
       subtitle = paste("AIC =", round(AIC3Medians, 2), ", R² =", round(r2_model3_median, 3)),
       x = "Log Median Ideal Rating",
       y = "Log Median Reasonable Rating") +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 12),
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 10)
  )

# Display plots
print(plot1_median)
print(plot2_median)
print(plot3_median)
print(plot4_median)

# Save plots
ggsave("model1_median_average_reasonable.png", plot1_median, width = 8, height = 6, dpi = 300)
ggsave("model2_median_ideal_reasonable.png", plot2_median, width = 8, height = 6, dpi = 300)
ggsave("model3_median_average_effect.png", plot3_median, width = 8, height = 6, dpi = 300)
ggsave("model3_median_ideal_effect.png", plot4_median, width = 8, height = 6, dpi = 300)

# Create a combined plot layout
grid_plots_median <- grid.arrange(plot1_median, plot2_median, plot3_median, plot4_median, ncol = 2)
ggsave("all_median_regression_plots.png", grid_plots_median, width = 14, height = 10, dpi = 300)

# Create a correlation matrix for median data
cor_matrix_median <- cor(dataforAICMedians, use = "complete.obs")
corrplot(cor_matrix_median, method = "color", 
        type = "upper", 
        addCoef.col = "black",
        tl.col = "black",
        tl.srt = 45,
        diag = FALSE,
        title = "Correlation Matrix (Median Values)",
        mar = c(0,0,1,0))

# Create detailed coefficient tables
model1_coefs_median <- get_model_coefs(Model1Medians)
model2_coefs_median <- get_model_coefs(Model2Medians)
model3_coefs_median <- get_model_coefs(Model3Medians)

# Format p-values
model1_coefs_median$p_value <- sapply(model1_coefs_median$p_value, format_pvalue)
model2_coefs_median$p_value <- sapply(model2_coefs_median$p_value, format_pvalue)
model3_coefs_median$p_value <- sapply(model3_coefs_median$p_value, format_pvalue)

# Display coefficient tables
kable(model1_coefs_median, caption = "Model 1 Coefficients for Median Values (Average → Reasonable)") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = F)

kable(model2_coefs_median, caption = "Model 2 Coefficients for Median Values (Ideal → Reasonable)") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = F)

kable(model3_coefs_median, caption = "Model 3 Coefficients for Median Values (Average + Ideal → Reasonable)") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = F)

# Print model summaries
cat("\nModel 1 Median Analysis (Average predicts Reasonable):\n")
print(summary(Model1Medians))

cat("\nModel 2 Median Analysis (Ideal predicts Reasonable):\n")
print(summary(Model2Medians))

cat("\nModel 3 Median Analysis (Average and Ideal predict Reasonable):\n")
print(summary(Model3Medians))

# Compare mean and median regressions
comparison_df <- data.frame(
  Model = c("Average predicts Reasonable", "Ideal predicts Reasonable", "Average + Ideal predict Reasonable"),
  Mean_Analysis_AIC = c(AIC1Means, AIC2Means, AIC3Means),
  Mean_Analysis_R2 = c(r2_model1, r2_model2, r2_model3),
  Median_Analysis_AIC = c(AIC1Medians, AIC2Medians, AIC3Medians),
  Median_Analysis_R2 = c(r2_model1_median, r2_model2_median, r2_model3_median)
)

kable(comparison_df, caption = "Comparison of Mean-Based and Median-Based Analyses") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = F)

# Store all the results in a structured list
analysis_3_results <- list(
  medians_by_question = medians_df,
  log_medians_by_question = log_medians_df,
  regression_models = list(
    model1 = Model1Medians,
    model2 = Model2Medians,
    model3 = Model3Medians
  ),
  regression_summary = regression_summary_medians,
  aic_values = c(AIC1 = AIC1Medians, AIC2 = AIC2Medians, AIC3 = AIC3Medians),
  comparison_with_means = comparison_df
)
```

# Analysis 4: Overall results, intermediacy [following Bear & Knobe 2016] with median ratings

#### Determine if each median reasonableness rating is on the "ideal side" of average

```{r}
# Function to check if reasonable is on the "ideal side" of average
# Equal median ratings are treated as being on the predicted side
is_ideal_side_median <- function(average, ideal, reasonable) {
  ifelse(abs(reasonable - ideal) <= abs(reasonable - average), 1, 0)
}

# Apply the function to the medians
ideal_side_vector_median <- mapply(is_ideal_side_median,
                                  column_medians_average,
                                  column_medians_ideal,
                                  column_medians_reasonable)

# Count how many questions have reasonableness on the "ideal side" of average
count_ideal_side_median <- sum(ideal_side_vector_median)

# Conduct binomial test to assess whether the proportion is greater than 50%
binomial_result_ideal_median <- binom.test(count_ideal_side_median, length(question_cols), p = 0.5, 
                                         alternative = "greater")

# Create a summary table for the binomial test results
ideal_side_summary_median <- data.frame(
  On_Ideal_Side_Count = count_ideal_side_median,
  Total_Questions = length(question_cols),
  Proportion = count_ideal_side_median/length(question_cols),
  p_value = binomial_result_ideal_median$p.value
)

# Format proportion and p-value for display
ideal_side_summary_median$Proportion <- scales::percent(ideal_side_summary_median$Proportion)
ideal_side_summary_median$p_value <- format_pvalue(ideal_side_summary_median$p_value)

# Display the binomial test results table
kable(ideal_side_summary_median, 
      caption = "Binomial Test Results: Is Median Reasonableness on the Ideal Side of Average?") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = F)
```

#### Determine if each median reasonableness rating is on the "ideal side" of average

```{r}
# Function to check if reasonable is on the "average side" of ideal
is_average_side_median <- function(average, ideal, reasonable) {
  ifelse(abs(reasonable - average) <= abs(reasonable - ideal), 1, 0)
}

# Apply the function to the medians
average_side_vector_median <- mapply(is_average_side_median,
                                    column_medians_average,
                                    column_medians_ideal,
                                    column_medians_reasonable)

# Count how many questions have reasonableness on the "average side" of ideal
count_average_side_median <- sum(average_side_vector_median)

# Conduct binomial test to assess whether the proportion is greater than 50%
binomial_result_avg_side_median <- binom.test(count_average_side_median, length(question_cols), p = 0.5, 
                                            alternative = "greater")

# Create a summary table for the binomial test results
average_side_summary_median <- data.frame(
  On_Average_Side_Count = count_average_side_median,
  Total_Questions = length(question_cols),
  Proportion = count_average_side_median/length(question_cols),
  p_value = binomial_result_avg_side_median$p.value
)

# Format proportion and p-value for display
average_side_summary_median$Proportion <- scales::percent(average_side_summary_median$Proportion)
average_side_summary_median$p_value <- format_pvalue(average_side_summary_median$p_value)

# Display the binomial test results table
kable(average_side_summary_median, 
      caption = "Binomial Test Results: Is Median Reasonableness on the Average Side of Ideal?") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = F)
```

#### Determine if median reasonableness is both on the ideal side of average and on the average side of ideal

```{r}
# Function to check if reasonable falls between average and ideal
# Using the same approach as Analysis 2
is_both_sides_median <- function(average, ideal, reasonable) {
  ifelse((reasonable - average) * (reasonable - ideal) <= 0, 1, 0)
}

# Apply the function to the medians
both_sides_vector_median <- mapply(is_both_sides_median,
                                  column_medians_average,
                                  column_medians_ideal,
                                  column_medians_reasonable)

# Count how many questions have reasonableness on both sides
count_both_sides_median <- sum(both_sides_vector_median)

# Conduct binomial test with 1/3 as the chance rate
binomial_result_both_sides_median <- binom.test(count_both_sides_median, length(question_cols), p = 1/3, 
                                              alternative = "two.sided")

# Create a summary table for the binomial test results
both_sides_summary_median <- data.frame(
  On_Both_Sides_Count = count_both_sides_median,
  Total_Questions = length(question_cols),
  Proportion = count_both_sides_median/length(question_cols),
  Expected_Chance = 1/3,
  p_value = binomial_result_both_sides_median$p.value
)

# Format proportions and p-values for display
both_sides_summary_median$Proportion <- scales::percent(both_sides_summary_median$Proportion)
both_sides_summary_median$Expected_Chance <- scales::percent(both_sides_summary_median$Expected_Chance)
both_sides_summary_median$p_value <- format_pvalue(both_sides_summary_median$p_value)

# Display the binomial test results table
kable(both_sides_summary_median, 
      caption = "Binomial Test Results: Is Median Reasonableness Between Average and Ideal?") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = F)
```

#### Plots and Reporting

```{r}
# Create a table showing the results for each question
question_position_summary_median <- data.frame(
  Question = names(column_medians_average),
  Average_Value = column_medians_average,
  Ideal_Value = column_medians_ideal,
  Reasonable_Value = column_medians_reasonable,
  On_Ideal_Side = ideal_side_vector_median,
  On_Average_Side = average_side_vector_median,
  Between_Average_And_Ideal = both_sides_vector_median
)

# Categorize each question's position
question_position_summary_median$Position <- "Other"
question_position_summary_median$Position[question_position_summary_median$Between_Average_And_Ideal == 1] <- "Between Average and Ideal"
question_position_summary_median$Position[question_position_summary_median$On_Ideal_Side == 1 & 
                                        question_position_summary_median$On_Average_Side == 0] <- "Beyond Ideal"
question_position_summary_median$Position[question_position_summary_median$On_Ideal_Side == 0 & 
                                        question_position_summary_median$On_Average_Side == 1] <- "Beyond Average"

# Display the question position summary
kable(question_position_summary_median[, c("Question", "Average_Value", "Ideal_Value", "Reasonable_Value", "Position")], 
      caption = "Position of Median Reasonable Rating Relative to Average and Ideal for Each Question") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = F)

# Count the number of questions in each position category
position_counts_median <- table(question_position_summary_median$Position)

# Create a data frame for the position summary
position_summary_median <- data.frame(
  Position = names(position_counts_median),
  Count = as.numeric(position_counts_median)
)

# Calculate the percentages manually to ensure they're numeric
position_summary_median$Percentage <- (position_summary_median$Count / sum(position_summary_median$Count)) * 100

# Round the percentages to one decimal place
position_summary_median$Percentage <- round(position_summary_median$Percentage, 1)

# Display the position count summary
kable(position_summary_median, 
      caption = "Distribution of Position Categories (Median Values)") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = F)

# Create a visualization showing the distribution of positions
position_distribution_plot_median <- ggplot(position_summary_median, aes(x = Position, y = Count, fill = Position)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = paste0(Count, " (", Percentage, "%)")), 
            vjust = -0.5, size = 4) +
  labs(title = "Distribution of Position Categories (Median Values)",
       subtitle = "Where does 'Reasonable' fall relative to 'Average' and 'Ideal'?",
       x = "Position Category",
       y = "Number of Questions") +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 12),
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 10),
    legend.position = "none"
  )

# Display the plot
print(position_distribution_plot_median)

# Save the position distribution plot
ggsave("position_distribution_median.png", position_distribution_plot_median, width = 10, height = 6, dpi = 300)

# Create a scatterplot showing the relative positions
intermediacy_plot_median <- ggplot(question_position_summary_median, aes(x = Average_Value, y = Ideal_Value)) +
  # Add a diagonal reference line where average = ideal
  geom_abline(intercept = 0, slope = 1, linetype = "dashed", alpha = 0.5) +
  # Add points for each question's average and ideal values
  geom_point(color = "gray60", size = 3, alpha = 0.6) +
  # Add points for reasonable values, colored by position category
  geom_point(aes(x = Average_Value, y = Reasonable_Value, color = Position), size = 4) +
  # Connect reasonable to average with a line
  geom_segment(aes(xend = Average_Value, yend = Reasonable_Value, color = Position), 
               linetype = "dotted", size = 0.5) +
  scale_color_brewer(palette = "Set1") +
  labs(title = "Intermediacy Analysis: Position of Median Reasonable Relative to Average and Ideal",
       subtitle = paste0("Questions with Reasonable between Average and Ideal: ", 
                         count_both_sides_median, " of ", length(question_cols), 
                         " (", scales::percent(count_both_sides_median/length(question_cols)), ")"),
       x = "Median Average Rating",
       y = "Rating Value",
       color = "Position Category") +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 12),
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 10),
    legend.position = "bottom"
  )

# Display the plot
print(intermediacy_plot_median)

# Save the intermediacy plot
ggsave("intermediacy_analysis_median.png", intermediacy_plot_median, width = 10, height = 8, dpi = 300)

# Create a more detailed plot showing all three ratings for each question
# Convert to long format for plotting
ratings_long_median <- question_position_summary_median %>%
  select(Question, Average_Value, Ideal_Value, Reasonable_Value, Position) %>%
  pivot_longer(cols = c(Average_Value, Ideal_Value, Reasonable_Value),
               names_to = "Rating_Type",
               values_to = "Value") %>%
  mutate(Rating_Type = gsub("_Value", "", Rating_Type))

# Plot the ratings for each question, grouped and colored
rating_patterns_plot_median <- ggplot(ratings_long_median, aes(x = Rating_Type, y = Value, group = Question, color = Position)) +
  geom_line(alpha = 0.6) +
  geom_point(size = 3) +
  facet_wrap(~ Position, scales = "free_y") +
  scale_color_brewer(palette = "Set1") +
  labs(title = "Rating Patterns by Position Category (Median Values)",
       subtitle = "How Average, Ideal, and Reasonable median ratings relate within each position category",
       x = "Rating Type",
       y = "Value") +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold"),
    plot.subtitle = element_text(size = 12),
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 10),
    legend.position = "none"
  )

# Display the plot
print(rating_patterns_plot_median)

# Save the ratings pattern plot
ggsave("rating_patterns_by_position_median.png", rating_patterns_plot_median, width = 12, height = 8, dpi = 300)

# Compare the results between mean-based and median-based intermediacy analyses
comparison_intermediacy <- data.frame(
  Analysis_Type = c("Mean-based Analysis", "Median-based Analysis"),
  On_Ideal_Side_Percentage = c(
    paste0(count_ideal_side, "/", length(question_cols), " (", scales::percent(count_ideal_side/length(question_cols)), ")"),
    paste0(count_ideal_side_median, "/", length(question_cols), " (", scales::percent(count_ideal_side_median/length(question_cols)), ")")
  ),
  On_Average_Side_Percentage = c(
    paste0(count_average_side, "/", length(question_cols), " (", scales::percent(count_average_side/length(question_cols)), ")"),
    paste0(count_average_side_median, "/", length(question_cols), " (", scales::percent(count_average_side_median/length(question_cols)), ")")
  ),
  Between_Average_And_Ideal_Percentage = c(
    paste0(count_both_sides, "/", length(question_cols), " (", scales::percent(count_both_sides/length(question_cols)), ")"),
    paste0(count_both_sides_median, "/", length(question_cols), " (", scales::percent(count_both_sides_median/length(question_cols)), ")")
  )
)

# Display the comparison table
kable(comparison_intermediacy, caption = "Comparison of Mean-based and Median-based Intermediacy Analyses") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = F)

# Store all the results in a structured list
analysis_4_results <- list(
  ideal_side = list(
    vector = ideal_side_vector_median,
    count = count_ideal_side_median,
    binomial_test = binomial_result_ideal_median,
    summary = ideal_side_summary_median
  ),
  average_side = list(
    vector = average_side_vector_median,
    count = count_average_side_median,
    binomial_test = binomial_result_avg_side_median,
    summary = average_side_summary_median
  ),
  both_sides = list(
    vector = both_sides_vector_median,
    count = count_both_sides_median,
    binomial_test = binomial_result_both_sides_median,
    summary = both_sides_summary_median
  ),
  question_position = question_position_summary_median,
  position_summary = position_summary_median,
  comparison_with_means = comparison_intermediacy
)
```

# Analysis 5: Overall results, mean ratings [following Bear & Knobe 2016] BY COUNTRY

```{r}
#### Get list of unique countries in the dataset (confirming ten)
countries <- unique(Data_All$Country_name)
print(paste("Number of countries in dataset:", length(countries)))
print("Countries included in analysis:")
print(countries)

# Create storage for country-specific results
country_results_mean <- list()
```
```{r}
# Function to analyze data for a single country
analyze_country_mean <- function(country) {
  cat("\n========== Analyzing Mean Data for:", country, "==========\n")
  
  # Step 1: Split data by condition for this country
  country_average <- Data_All_Average %>% filter(Country_name == country)
  country_ideal <- Data_All_Ideal %>% filter(Country_name == country)
  country_reasonable <- Data_All_Reasonable %>% filter(Country_name == country)
  
  # Apply attention check filter (q19 == 15)
  country_average_pass <- country_average %>% filter(q19 == 15)
  country_ideal_pass <- country_ideal %>% filter(q19 == 15)
  country_reasonable_pass <- country_reasonable %>% filter(q19 == 15)
  
  # Print participant counts
  cat("Participants after attention check filter:\n")
  cat("Average condition:", nrow(country_average_pass), "\n")
  cat("Ideal condition:", nrow(country_ideal_pass), "\n")
  cat("Reasonable condition:", nrow(country_reasonable_pass), "\n")
  
  # Convert columns to numeric
  country_average_pass <- country_average_pass %>%
    mutate(across(all_of(question_cols), ~as.numeric(as.character(.))))
  
  country_ideal_pass <- country_ideal_pass %>%
    mutate(across(all_of(question_cols), ~as.numeric(as.character(.))))
  
  country_reasonable_pass <- country_reasonable_pass %>%
    mutate(across(all_of(question_cols), ~as.numeric(as.character(.))))
  
  # Step 2: Apply 3 SD filtering
  # For average condition
  country_avg_filter_results <- filter_data(country_average_pass, question_cols)
  country_average_filtered <- country_avg_filter_results$filtered_data
  
  # For ideal condition
  country_ideal_filter_results <- filter_data(country_ideal_pass, question_cols)
  country_ideal_filtered <- country_ideal_filter_results$filtered_data
  
  # For reasonable condition
  country_reasonable_filter_results <- filter_data(country_reasonable_pass, question_cols)
  country_reasonable_filtered <- country_reasonable_filter_results$filtered_data
  
  # Calculate means after filtering
  country_means_average <- sapply(country_average_filtered[, question_cols], mean, na.rm = TRUE)
  country_means_ideal <- sapply(country_ideal_filtered[, question_cols], mean, na.rm = TRUE)
  country_means_reasonable <- sapply(country_reasonable_filtered[, question_cols], mean, na.rm = TRUE)
  
  # Step 3: Convert to log scale
  country_log_means_average <- safe_log(country_means_average)
  country_log_means_ideal <- safe_log(country_means_ideal)
  country_log_means_reasonable <- safe_log(country_means_reasonable)
  
  # Step 4: Run regression models
  country_dataforAIC <- data.frame(
    Reasonable = country_log_means_reasonable,
    Average = country_log_means_average,
    Ideal = country_log_means_ideal
  )
  
  # Skip regression if we have too few data points
  if(nrow(country_dataforAIC) < 5) {
    cat("Too few data points for regression analysis in", country, "\n")
    return(NULL)
  }
  
  # Model I: Average predicts reasonable
  country_model1 <- lm(Reasonable ~ Average, data = country_dataforAIC)
  country_aic1 <- AIC(country_model1)
  country_r2_1 <- summary(country_model1)$r.squared
  
  # Model II: Ideal predicts reasonable
  country_model2 <- lm(Reasonable ~ Ideal, data = country_dataforAIC)
  country_aic2 <- AIC(country_model2)
  country_r2_2 <- summary(country_model2)$r.squared
  
  # Model III: Both average and ideal predict reasonable
  country_model3 <- lm(Reasonable ~ Average + Ideal, data = country_dataforAIC)
  country_aic3 <- AIC(country_model3)
  country_r2_3 <- summary(country_model3)$r.squared
  
  # Create regression summary
  country_reg_summary <- data.frame(
    Model = c("Average predicts Reasonable", 
              "Ideal predicts Reasonable", 
              "Average + Ideal predict Reasonable"),
    AIC = c(country_aic1, country_aic2, country_aic3),
    R_squared = c(country_r2_1, country_r2_2, country_r2_3)
  )
  
  # Determine which model has the lowest AIC (best fit)
  best_model_idx <- which.min(c(country_aic1, country_aic2, country_aic3))
  best_model_name <- c("Average", "Ideal", "Hybrid")[best_model_idx]
  
  cat("\nRegression Results for", country, ":\n")
  print(country_reg_summary)
  cat("\nBest model for", country, "is:", best_model_name, "\n")
  
  # Return results for this country
  return(list(
    country = country,
    sample_sizes = list(
      original = c(nrow(country_average), nrow(country_ideal), nrow(country_reasonable)),
      after_attention = c(nrow(country_average_pass), nrow(country_ideal_pass), nrow(country_reasonable_pass)),
      after_filtering = c(nrow(country_average_filtered), nrow(country_ideal_filtered), nrow(country_reasonable_filtered))
    ),
    means = list(
      average = country_means_average,
      ideal = country_means_ideal,
      reasonable = country_means_reasonable
    ),
    log_means = list(
      average = country_log_means_average,
      ideal = country_log_means_ideal,
      reasonable = country_log_means_reasonable
    ),
    regression_models = list(
      model1 = country_model1,
      model2 = country_model2,
      model3 = country_model3
    ),
    regression_summary = country_reg_summary,
    aic_values = c(Model1 = country_aic1, Model2 = country_aic2, Model3 = country_aic3),
    best_model = best_model_name
  ))
}

```

```{r}
# Analyze data for each country
for(country in countries) {
  country_results_mean[[country]] <- analyze_country_mean(country)
}

# Extract AIC values and best models for all countries
country_aic_summary <- data.frame(
  Country = character(),
  AIC_Average = numeric(),
  AIC_Ideal = numeric(),
  AIC_Hybrid = numeric(),
  R2_Average = numeric(),
  R2_Ideal = numeric(),
  R2_Hybrid = numeric(),
  Best_Model = character(),
  stringsAsFactors = FALSE
)

for(country in countries) {
  if(!is.null(country_results_mean[[country]])) {
    country_aic_summary <- rbind(country_aic_summary, data.frame(
      Country = country,
      AIC_Average = country_results_mean[[country]]$aic_values["Model1"],
      AIC_Ideal = country_results_mean[[country]]$aic_values["Model2"],
      AIC_Hybrid = country_results_mean[[country]]$aic_values["Model3"],
      R2_Average = country_results_mean[[country]]$regression_summary$R_squared[1],
      R2_Ideal = country_results_mean[[country]]$regression_summary$R_squared[2],
      R2_Hybrid = country_results_mean[[country]]$regression_summary$R_squared[3],
      Best_Model = country_results_mean[[country]]$best_model,
      stringsAsFactors = FALSE
    ))
  }
}

# Display the summary table
kable(country_aic_summary, 
      caption = "AIC Values and Best Models by Country (Mean Analysis)") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = F) %>%
  column_spec(8, background = ifelse(country_aic_summary$Best_Model == "Hybrid", "#e6f7ff", 
                                   ifelse(country_aic_summary$Best_Model == "Average", "#e6ffe6", "#ffe6e6")))

# Count best models
best_model_counts <- table(country_aic_summary$Best_Model)

# Create a bar chart of best models by country
ggplot(country_aic_summary, aes(x = reorder(Country, -AIC_Hybrid), y = AIC_Hybrid, fill = Best_Model)) +
  geom_bar(stat = "identity") +
  geom_text(aes(label = Best_Model), vjust = -0.5, size = 3) +
  labs(title = "Model Comparison Across Countries (Mean Analysis)",
       subtitle = "Hybrid Model AIC Values with Best Model Indicated",
       x = "Country",
       y = "AIC Value (Hybrid Model)",
       fill = "Best Model") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Create plots showing regression results for each country
country_plots <- list()

for(country in countries) {
  if(!is.null(country_results_mean[[country]])) {
    # Create a dataframe for plotting
    plot_data <- data.frame(
      Average = country_results_mean[[country]]$log_means$average,
      Ideal = country_results_mean[[country]]$log_means$ideal,
      Reasonable = country_results_mean[[country]]$log_means$reasonable
    )
    
    # Create plot for this country
    country_plot <- ggplot(plot_data) +
      geom_point(aes(x = Average, y = Reasonable), color = "blue", size = 3) +
      geom_smooth(aes(x = Average, y = Reasonable), method = "lm", se = TRUE, color = "blue", linetype = "solid") +
      geom_point(aes(x = Ideal, y = Reasonable), color = "red", size = 3) +
      geom_smooth(aes(x = Ideal, y = Reasonable), method = "lm", se = TRUE, color = "red", linetype = "dashed") +
      labs(title = paste0("Regression Results for ", country),
           subtitle = paste0("Best model: ", country_results_mean[[country]]$best_model),
           x = "Log Predictor Values",
           y = "Log Reasonable Values") +
      theme_minimal() +
      annotate("text", x = min(plot_data$Average, plot_data$Ideal, na.rm = TRUE), 
               y = max(plot_data$Reasonable, na.rm = TRUE),
               label = paste0("Average R² = ", round(country_results_mean[[country]]$regression_summary$R_squared[1], 3),
                            "\nIdeal R² = ", round(country_results_mean[[country]]$regression_summary$R_squared[2], 3),
                            "\nHybrid R² = ", round(country_results_mean[[country]]$regression_summary$R_squared[3], 3)),
               hjust = 0, vjust = 1)
    
    country_plots[[country]] <- country_plot
    print(country_plot)
  }
}

# Create plots comparing the regression coefficients across countries
# Extract coefficients for Average and Ideal from the hybrid model
coefficient_data <- data.frame(
  Country = character(),
  Average_Coef = numeric(),
  Average_P = numeric(),
  Ideal_Coef = numeric(),
  Ideal_P = numeric(),
  stringsAsFactors = FALSE
)

for(country in countries) {
  if(!is.null(country_results_mean[[country]])) {
    # Extract coefficients from hybrid model
    model3_coefs <- summary(country_results_mean[[country]]$regression_models$model3)$coefficients
    
    if(nrow(model3_coefs) >= 3) {  # Ensure we have coefficients for both predictors
      coefficient_data <- rbind(coefficient_data, data.frame(
        Country = country,
        Average_Coef = model3_coefs[2, 1],  # Coefficient for Average
        Average_P = model3_coefs[2, 4],     # p-value for Average
        Ideal_Coef = model3_coefs[3, 1],    # Coefficient for Ideal
        Ideal_P = model3_coefs[3, 4],       # p-value for Ideal
        stringsAsFactors = FALSE
      ))
    }
  }
}

# Format p-values
coefficient_data$Average_Sig <- ifelse(coefficient_data$Average_P < 0.05, "*", "")
coefficient_data$Ideal_Sig <- ifelse(coefficient_data$Ideal_P < 0.05, "*", "")

# Create long format for coefficient plotting
coef_long <- coefficient_data %>%
  select(Country, Average_Coef, Ideal_Coef) %>%
  pivot_longer(cols = c(Average_Coef, Ideal_Coef),
               names_to = "Predictor",
               values_to = "Coefficient") %>%
  mutate(Predictor = gsub("_Coef", "", Predictor))

# Create coefficient plot
ggplot(coef_long, aes(x = Country, y = Coefficient, fill = Predictor)) +
  geom_bar(stat = "identity", position = position_dodge()) +
  geom_text(aes(label = ifelse(Predictor == "Average", 
                              coefficient_data$Average_Sig[match(Country, coefficient_data$Country)],
                              coefficient_data$Ideal_Sig[match(Country, coefficient_data$Country)])),
            position = position_dodge(width = 0.9), vjust = -0.5) +
  labs(title = "Regression Coefficients by Country (Hybrid Model)",
       subtitle = "* indicates p < 0.05",
       x = "Country",
       y = "Coefficient Value") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Save results
analysis_5_results <- list(
  country_results = country_results_mean,
  aic_summary = country_aic_summary,
  coefficient_data = coefficient_data
)
```

# Analysis 6: Overall results, intermediacy [following Bear & Knobe 2016] BY COUNTRY

```{r}
# Create storage for country-specific intermediacy results
country_intermediacy_results <- list()

# Function to analyze intermediacy for a single country
analyze_country_intermediacy <- function(country) {
  cat("\n========== Analyzing Intermediacy for:", country, "==========\n")
  
  # We'll use the filtered mean data from Analysis 5
  # If country data wasn't successfully processed in Analysis 5, return NULL
  if(is.null(country_results_mean[[country]])) {
    cat("No valid data for", country, "\n")
    return(NULL)
  }
  
  # Extract the mean values
  country_means_average <- country_results_mean[[country]]$means$average
  country_means_ideal <- country_results_mean[[country]]$means$ideal
  country_means_reasonable <- country_results_mean[[country]]$means$reasonable
  
  # Step 3: Check if reasonable is on the "ideal side" of average
  ideal_side_vector <- mapply(is_both_sides,
                             country_means_average,
                             country_means_ideal,
                             country_means_reasonable)
  
  count_ideal_side <- sum(ideal_side_vector)
  
  # Conduct binomial test
  binomial_result_ideal <- binom.test(count_ideal_side, length(ideal_side_vector), 
                                     p = 0.5, alternative = "greater")
  
  # Step 4: Check if reasonable is on the "average side" of ideal
  average_side_vector <- mapply(is_average_side,
                               country_means_average,
                               country_means_ideal,
                               country_means_reasonable)
  
  count_average_side <- sum(average_side_vector)
  
  # Conduct binomial test
  binomial_result_avg_side <- binom.test(count_average_side, length(average_side_vector), 
                                        p = 0.5, alternative = "greater")
  
  # Step 5: Check if reasonable is both on the ideal side of average and average side of ideal
  both_sides_vector <- mapply(is_both_sides,
                             country_means_average,
                             country_means_ideal,
                             country_means_reasonable)
  
  count_both_sides <- sum(both_sides_vector)
  
  # Conduct binomial test with 1/3 as the chance rate
  binomial_result_both_sides <- binom.test(count_both_sides, length(both_sides_vector), 
                                          p = 1/3, alternative = "two.sided")
  
  # Create a summary table
  intermediacy_summary <- data.frame(
    Test = c("On Ideal Side of Average", "On Average Side of Ideal", "Between Average and Ideal"),
    Count = c(count_ideal_side, count_average_side, count_both_sides),
    Total = rep(length(ideal_side_vector), 3),
    Proportion = c(count_ideal_side/length(ideal_side_vector), 
                  count_average_side/length(average_side_vector), 
                  count_both_sides/length(both_sides_vector)),
    p_value = c(binomial_result_ideal$p.value, 
               binomial_result_avg_side$p.value, 
               binomial_result_both_sides$p.value)
  )
  
  # Format proportions and p-values
  intermediacy_summary$Proportion <- scales::percent(intermediacy_summary$Proportion)
  intermediacy_summary$p_value <- sapply(intermediacy_summary$p_value, format_pvalue)
  
  cat("\nIntermediary Analysis for", country, ":\n")
  print(intermediacy_summary)
  
  # Return results
  return(list(
    country = country,
    ideal_side = list(
      vector = ideal_side_vector,
      count = count_ideal_side,
      proportion = count_ideal_side/length(ideal_side_vector),
      binomial_test = binomial_result_ideal
    ),
    average_side = list(
      vector = average_side_vector,
      count = count_average_side,
      proportion = count_average_side/length(average_side_vector),
      binomial_test = binomial_result_avg_side
    ),
    both_sides = list(
      vector = both_sides_vector,
      count = count_both_sides,
      proportion = count_both_sides/length(both_sides_vector),
      binomial_test = binomial_result_both_sides
    ),
    summary = intermediacy_summary
  ))
}
```

```{r}
# Analyze intermediacy for each country
for(country in countries) {
  country_intermediacy_results[[country]] <- analyze_country_intermediacy(country)
}

# Create summary table for intermediacy across countries
intermediacy_by_country <- data.frame(
  Country = character(),
  Ideal_Side_Proportion = numeric(),
  Ideal_Side_P = numeric(),
  Average_Side_Proportion = numeric(),
  Average_Side_P = numeric(),
  Between_Proportion = numeric(),
  Between_P = numeric(),
  stringsAsFactors = FALSE
)

for(country in countries) {
  if(!is.null(country_intermediacy_results[[country]])) {
    intermediacy_by_country <- rbind(intermediacy_by_country, data.frame(
      Country = country,
      Ideal_Side_Proportion = country_intermediacy_results[[country]]$ideal_side$proportion,
      Ideal_Side_P = country_intermediacy_results[[country]]$ideal_side$binomial_test$p.value,
      Average_Side_Proportion = country_intermediacy_results[[country]]$average_side$proportion,
      Average_Side_P = country_intermediacy_results[[country]]$average_side$binomial_test$p.value,
      Between_Proportion = country_intermediacy_results[[country]]$both_sides$proportion,
      Between_P = country_intermediacy_results[[country]]$both_sides$binomial_test$p.value,
      stringsAsFactors = FALSE
    ))
  }
}

# Format the proportions as percentages
intermediacy_by_country$Ideal_Side_Proportion <- scales::percent(intermediacy_by_country$Ideal_Side_Proportion)
intermediacy_by_country$Average_Side_Proportion <- scales::percent(intermediacy_by_country$Average_Side_Proportion)
intermediacy_by_country$Between_Proportion <- scales::percent(intermediacy_by_country$Between_Proportion)

# Add significance indicators
intermediacy_by_country$Ideal_Side_Sig <- ifelse(intermediacy_by_country$Ideal_Side_P < 0.05, "*", "")
intermediacy_by_country$Average_Side_Sig <- ifelse(intermediacy_by_country$Average_Side_P < 0.05, "*", "")
intermediacy_by_country$Between_Sig <- ifelse(intermediacy_by_country$Between_P < 0.05, "*", "")

# Create display table
display_intermediacy <- intermediacy_by_country %>%
  select(Country, 
         Ideal_Side = Ideal_Side_Proportion, 
         Ideal_Sig = Ideal_Side_Sig,
         Average_Side = Average_Side_Proportion, 
         Average_Sig = Average_Side_Sig,
         Between = Between_Proportion,
         Between_Sig = Between_Sig)

# Display the table
kable(display_intermediacy, 
      caption = "Intermediacy Analysis by Country (Mean Values)") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = F) %>%
  add_header_above(c(" " = 1, "Ideal Side of Average" = 2, "Average Side of Ideal" = 2, "Between Average and Ideal" = 2))

# Create a visualization of the "Between" proportions across countries
between_plot <- ggplot(intermediacy_by_country, aes(x = reorder(Country, -as.numeric(gsub("%", "", Between_Proportion))/100), 
                                                 y = as.numeric(gsub("%", "", Between_Proportion))/100)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  geom_text(aes(label = paste0(Between_Proportion, Between_Sig)), vjust = -0.5) +
  geom_hline(yintercept = 1/3, linetype = "dashed", color = "red") +
  labs(title = "Proportion of Questions where Reasonable is Between Average and Ideal",
       subtitle = "By Country (Mean Analysis), Red line = Chance level (1/3), * = p < 0.05",
       x = "Country",
       y = "Proportion") +
  scale_y_continuous(labels = scales::percent) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

print(between_plot)
ggsave("between_proportions_by_country.png", between_plot, width = 10, height = 6, dpi = 300)

# Save the results
analysis_6_results <- list(
  country_results = country_intermediacy_results,
  summary = intermediacy_by_country
)
```

# Analysis 7: Overall results, with median ratings BY COUNTRY

```{r}
# Create storage for country-specific median results
country_results_median <- list()

# Function to analyze median data for a single country
analyze_country_median <- function(country) {
  cat("\n========== Analyzing Median Data for:", country, "==========\n")
  
  # Step 1: Split data by condition for this country
  country_average <- Data_All_Average %>% filter(Country_name == country)
  country_ideal <- Data_All_Ideal %>% filter(Country_name == country)
  country_reasonable <- Data_All_Reasonable %>% filter(Country_name == country)
  
  # Apply attention check filter (q19 == 15)
  country_average_pass <- country_average %>% filter(q19 == 15)
  country_ideal_pass <- country_ideal %>% filter(q19 == 15)
  country_reasonable_pass <- country_reasonable %>% filter(q19 == 15)
  
  # Print participant counts
  cat("Participants after attention check filter:\n")
  cat("Average condition:", nrow(country_average_pass), "\n")
  cat("Ideal condition:", nrow(country_ideal_pass), "\n")
  cat("Reasonable condition:", nrow(country_reasonable_pass), "\n")
  
  # Convert columns to numeric
  country_average_pass <- country_average_pass %>%
    mutate(across(all_of(question_cols), ~as.numeric(as.character(.))))
  
  country_ideal_pass <- country_ideal_pass %>%
    mutate(across(all_of(question_cols), ~as.numeric(as.character(.))))
  
  country_reasonable_pass <- country_reasonable_pass %>%
    mutate(across(all_of(question_cols), ~as.numeric(as.character(.))))
  
  # Step 2: Calculate medians (no 3 SD filtering for median analysis)
  country_medians_average <- sapply(country_average_pass[, question_cols], median, na.rm = TRUE)
  country_medians_ideal <- sapply(country_ideal_pass[, question_cols], median, na.rm = TRUE)
  country_medians_reasonable <- sapply(country_reasonable_pass[, question_cols], median, na.rm = TRUE)
  
  # Step 3: Convert to log scale
  country_log_medians_average <- safe_log(country_medians_average)
  country_log_medians_ideal <- safe_log(country_medians_ideal)
  country_log_medians_reasonable <- safe_log(country_medians_reasonable)
  
  # Step 4: Run regression models
  country_dataforAIC_median <- data.frame(
    Reasonable = country_log_medians_reasonable,
    Average = country_log_medians_average,
    Ideal = country_log_medians_ideal
  )
  
  # Skip regression if we have too few data points
  if(nrow(country_dataforAIC_median) < 5) {
    cat("Too few data points for regression analysis in", country, "\n")
    return(NULL)
  }
  
  # Model I: Average predicts reasonable
  country_model1_median <- lm(Reasonable ~ Average, data = country_dataforAIC_median)
  country_aic1_median <- AIC(country_model1_median)
  country_r2_1_median <- summary(country_model1_median)$r.squared
  
  # Model II: Ideal predicts reasonable
  country_model2_median <- lm(Reasonable ~ Ideal, data = country_dataforAIC_median)
  country_aic2_median <- AIC(country_model2_median)
  country_r2_2_median <- summary(country_model2_median)$r.squared
  
  # Model III: Both average and ideal predict reasonable
  country_model3_median <- lm(Reasonable ~ Average + Ideal, data = country_dataforAIC_median)
  country_aic3_median <- AIC(country_model3_median)
  country_r2_3_median <- summary(country_model3_median)$r.squared
  
  # Create regression summary
  country_reg_summary_median <- data.frame(
    Model = c("Average predicts Reasonable", 
              "Ideal predicts Reasonable", 
              "Average + Ideal predict Reasonable"),
    AIC = c(country_aic1_median, country_aic2_median, country_aic3_median),
    R_squared = c(country_r2_1_median, country_r2_2_median, country_r2_3_median)
  )
  
  # Determine which model has the lowest AIC (best fit)
  best_model_idx <- which.min(c(country_aic1_median, country_aic2_median, country_aic3_median))
  best_model_name <- c("Average", "Ideal", "Hybrid")[best_model_idx]
  
  cat("\nRegression Results for", country, "(Median Analysis):\n")
  print(country_reg_summary_median)
  cat("\nBest model for", country, "is:", best_model_name, "\n")
  
  # Return results for this country
  return(list(
    country = country,
    sample_sizes = list(
      after_attention = c(nrow(country_average_pass), nrow(country_ideal_pass), nrow(country_reasonable_pass))
    ),
    medians = list(
      average = country_medians_average,
      ideal = country_medians_ideal,
      reasonable = country_medians_reasonable
    ),
    log_medians = list(
      average = country_log_medians_average,
      ideal = country_log_medians_ideal,
      reasonable = country_log_medians_reasonable
    ),
    regression_models = list(
      model1 = country_model1_median,
      model2 = country_model2_median,
      model3 = country_model3_median
    ),
    regression_summary = country_reg_summary_median,
    aic_values = c(Model1 = country_aic1_median, Model2 = country_aic2_median, Model3 = country_aic3_median),
    best_model = best_model_name
  ))
}
```

```{r}
# Analyze median data for each country
for(country in countries) {
  country_results_median[[country]] <- analyze_country_median(country)
}

# Extract AIC values and best models for all countries (median analysis)
country_aic_summary_median <- data.frame(
  Country = character(),
  AIC_Average = numeric(),
  AIC_Ideal = numeric(),
  AIC_Hybrid = numeric(),
  R2_Average = numeric(),
  R2_Ideal = numeric(),
  R2_Hybrid = numeric(),
  Best_Model = character(),
  stringsAsFactors = FALSE
)

for(country in countries) {
  if(!is.null(country_results_median[[country]])) {
    country_aic_summary_median <- rbind(country_aic_summary_median, data.frame(
      Country = country,
      AIC_Average = country_results_median[[country]]$aic_values["Model1"],
      AIC_Ideal = country_results_median[[country]]$aic_values["Model2"],
      AIC_Hybrid = country_results_median[[country]]$aic_values["Model3"],
      R2_Average = country_results_median[[country]]$regression_summary$R_squared[1],
      R2_Ideal = country_results_median[[country]]$regression_summary$R_squared[2],
      R2_Hybrid = country_results_median[[country]]$regression_summary$R_squared[3],
      Best_Model = country_results_median[[country]]$best_model,
      stringsAsFactors = FALSE
    ))
  }
}

# Display the summary table
kable(country_aic_summary_median, 
      caption = "AIC Values and Best Models by Country (Median Analysis)") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = F) %>%
  column_spec(8, background = ifelse(country_aic_summary_median$Best_Model == "Hybrid", "#e6f7ff", 
                                   ifelse(country_aic_summary_median$Best_Model == "Average", "#e6ffe6", "#ffe6e6")))

# Compare mean and median analysis
comparison_mean_median <- data.frame(
  Country = character(),
  Mean_Best_Model = character(),
  Median_Best_Model = character(),
  Mean_Hybrid_AIC = numeric(),
  Median_Hybrid_AIC = numeric(),
  Mean_Hybrid_R2 = numeric(),
  Median_Hybrid_R2 = numeric(),
  stringsAsFactors = FALSE
)

for(country in countries) {
  if(!is.null(country_results_mean[[country]]) && !is.null(country_results_median[[country]])) {
    comparison_mean_median <- rbind(comparison_mean_median, data.frame(
      Country = country,
      Mean_Best_Model = country_results_mean[[country]]$best_model,
      Median_Best_Model = country_results_median[[country]]$best_model,
      Mean_Hybrid_AIC = country_results_mean[[country]]$aic_values["Model3"],
      Median_Hybrid_AIC = country_results_median[[country]]$aic_values["Model3"],
      Mean_Hybrid_R2 = country_results_mean[[country]]$regression_summary$R_squared[3],
      Median_Hybrid_R2 = country_results_median[[country]]$regression_summary$R_squared[3],
      stringsAsFactors = FALSE
    ))
  }
}

# Display the comparison table
kable(comparison_mean_median, 
      caption = "Comparison of Mean and Median Analyses by Country") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = F) %>%
  column_spec(2, background = ifelse(comparison_mean_median$Mean_Best_Model == "Hybrid", "#e6f7ff", 
                                   ifelse(comparison_mean_median$Mean_Best_Model == "Average", "#e6ffe6", "#ffe6e6"))) %>%
  column_spec(3, background = ifelse(comparison_mean_median$Median_Best_Model == "Hybrid", "#e6f7ff", 
                                   ifelse(comparison_mean_median$Median_Best_Model == "Average", "#e6ffe6", "#ffe6e6")))

# Save results
analysis_7_results <- list(
  country_results = country_results_median,
  aic_summary = country_aic_summary_median,
  comparison_with_means = comparison_mean_median
)
```

# Analysis 8: Overall results, intermediacy, with median ratings BY COUNTRY

```{r}
# Create storage for country-specific median intermediacy results
country_intermediacy_results_median <- list()

# Function to analyze median intermediacy for a single country
analyze_country_intermediacy_median <- function(country) {
  cat("\n========== Analyzing Median Intermediacy for:", country, "==========\n")
  
  # Use the median data from Analysis 7
  # If country data wasn't successfully processed in Analysis 7, return NULL
  if(is.null(country_results_median[[country]])) {
    cat("No valid data for", country, "\n")
    return(NULL)
  }
  
  # Extract the median values
  country_medians_average <- country_results_median[[country]]$medians$average
  country_medians_ideal <- country_results_median[[country]]$medians$ideal
  country_medians_reasonable <- country_results_median[[country]]$medians$reasonable
  
  # Step 3: Check if reasonable is on the "ideal side" of average
  # Note: For median analysis, we treat equal values as being on the predicted side
  ideal_side_vector_median <- mapply(is_ideal_side_median,
                                    country_medians_average,
                                    country_medians_ideal,
                                    country_medians_reasonable)
  
  count_ideal_side_median <- sum(ideal_side_vector_median)
  
  # Conduct binomial test
  binomial_result_ideal_median <- binom.test(count_ideal_side_median, length(ideal_side_vector_median), 
                                           p = 0.5, alternative = "greater")
  
  # Step 4: Check if reasonable is on the "average side" of ideal
  average_side_vector_median <- mapply(is_average_side_median,
                                      country_medians_average,
                                      country_medians_ideal,
                                      country_medians_reasonable)
  
  count_average_side_median <- sum(average_side_vector_median)
  
  # Conduct binomial test
  binomial_result_avg_side_median <- binom.test(count_average_side_median, length(average_side_vector_median), 
                                              p = 0.5, alternative = "greater")
  
  # Step 5: Check if reasonable is both on the ideal side of average and average side of ideal
  both_sides_vector_median <- mapply(is_both_sides_median,
                                    country_medians_average,
                                    country_medians_ideal,
                                    country_medians_reasonable)
  
  count_both_sides_median <- sum(both_sides_vector_median)
  
  # Conduct binomial test with 1/3 as the chance rate
  binomial_result_both_sides_median <- binom.test(count_both_sides_median, length(both_sides_vector_median), 
                                                p = 1/3, alternative = "two.sided")
  
  # Create a summary table
  intermediacy_summary_median <- data.frame(
    Test = c("On Ideal Side of Average", "On Average Side of Ideal", "Between Average and Ideal"),
    Count = c(count_ideal_side_median, count_average_side_median, count_both_sides_median),
    Total = rep(length(ideal_side_vector_median), 3),
    Proportion = c(count_ideal_side_median/length(ideal_side_vector_median), 
                  count_average_side_median/length(average_side_vector_median), 
                  count_both_sides_median/length(both_sides_vector_median)),
    p_value = c(binomial_result_ideal_median$p.value, 
               binomial_result_avg_side_median$p.value, 
               binomial_result_both_sides_median$p.value)
  )
  
  # Format proportions and p-values
  intermediacy_summary_median$Proportion <- scales::percent(intermediacy_summary_median$Proportion)
  intermediacy_summary_median$p_value <- sapply(intermediacy_summary_median$p_value, format_pvalue)
  
  cat("\nMedian Intermediary Analysis for", country, ":\n")
  print(intermediacy_summary_median)
  
  # Return results
  return(list(
    country = country,
    ideal_side = list(
      vector = ideal_side_vector_median,
      count = count_ideal_side_median,
      proportion = count_ideal_side_median/length(ideal_side_vector_median),
      binomial_test = binomial_result_ideal_median
    ),
    average_side = list(
      vector = average_side_vector_median,
      count = count_average_side_median,
      proportion = count_average_side_median/length(average_side_vector_median),
      binomial_test = binomial_result_avg_side_median
    ),
    both_sides = list(
      vector = both_sides_vector_median,
      count = count_both_sides_median,
      proportion = count_both_sides_median/length(both_sides_vector_median),
      binomial_test = binomial_result_both_sides_median
    ),
    summary = intermediacy_summary_median
  ))
}
```

```{r}
# Analyze median intermediacy for each country
for(country in countries) {
  country_intermediacy_results_median[[country]] <- analyze_country_intermediacy_median(country)
}

# Create summary table for median intermediacy across countries
intermediacy_by_country_median <- data.frame(
  Country = character(),
  Ideal_Side_Proportion = numeric(),
  Ideal_Side_P = numeric(),
  Average_Side_Proportion = numeric(),
  Average_Side_P = numeric(),
  Between_Proportion = numeric(),
  Between_P = numeric(),
  stringsAsFactors = FALSE
)

for(country in countries) {
  if(!is.null(country_intermediacy_results_median[[country]])) {
    intermediacy_by_country_median <- rbind(intermediacy_by_country_median, data.frame(
      Country = country,
      Ideal_Side_Proportion = country_intermediacy_results_median[[country]]$ideal_side$proportion,
      Ideal_Side_P = country_intermediacy_results_median[[country]]$ideal_side$binomial_test$p.value,
      Average_Side_Proportion = country_intermediacy_results_median[[country]]$average_side$proportion,
      Average_Side_P = country_intermediacy_results_median[[country]]$average_side$binomial_test$p.value,
      Between_Proportion = country_intermediacy_results_median[[country]]$both_sides$proportion,
      Between_P = country_intermediacy_results_median[[country]]$both_sides$binomial_test$p.value,
      stringsAsFactors = FALSE
    ))
  }
}

# Format the proportions as percentages
intermediacy_by_country_median$Ideal_Side_Proportion <- scales::percent(intermediacy_by_country_median$Ideal_Side_Proportion)
intermediacy_by_country_median$Average_Side_Proportion <- scales::percent(intermediacy_by_country_median$Average_Side_Proportion)
intermediacy_by_country_median$Between_Proportion <- scales::percent(intermediacy_by_country_median$Between_Proportion)

# Add significance indicators
intermediacy_by_country_median$Ideal_Side_Sig <- ifelse(intermediacy_by_country_median$Ideal_Side_P < 0.05, "*", "")
intermediacy_by_country_median$Average_Side_Sig <- ifelse(intermediacy_by_country_median$Average_Side_P < 0.05, "*", "")
intermediacy_by_country_median$Between_Sig <- ifelse(intermediacy_by_country_median$Between_P < 0.05, "*", "")

# Create display table
display_intermediacy_median <- intermediacy_by_country_median %>%
  select(Country, 
         Ideal_Side = Ideal_Side_Proportion, 
         Ideal_Sig = Ideal_Side_Sig,
         Average_Side = Average_Side_Proportion, 
         Average_Sig = Average_Side_Sig,
         Between = Between_Proportion,
         Between_Sig = Between_Sig)

# Display the table
kable(display_intermediacy_median, 
      caption = "Intermediacy Analysis by Country (Median Values)") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), full_width = F) %>%
  add_header_above(c(" " = 1, "Ideal Side of Average" = 2, "Average Side of Ideal" = 2, "Between Average and Ideal" = 2))

# Compare mean and median intermediacy results
comparison_intermediacy_mean_median <- data.frame(
  Country = character(),
  Mean_Ideal_Side = character(),
  Median_Ideal_Side = character(),
  Mean_Average_Side = character(),
  Median_Average_Side = character(),
  Mean_Between = character(),
  Median_Between = character(),
  stringsAsFactors = FALSE
)

# Create a visualization comparing "Between" proportions for mean vs median analyses
between_data_long <- data.frame(
  Country = rep(intermediacy_by_country$Country, 2),
  Analysis_Type = c(rep("Mean", nrow(intermediacy_by_country)), rep("Median", nrow(intermediacy_by_country_median))),
  Between_Proportion = c(as.numeric(gsub("%", "", intermediacy_by_country$Between_Proportion))/100,
                         as.numeric(gsub("%", "", intermediacy_by_country_median$Between_Proportion))/100),
  Significant = c(intermediacy_by_country$Between_P < 0.05, 
                  intermediacy_by_country_median$Between_P < 0.05)
)

# Plot the comparison
between_comparison_plot <- ggplot(between_data_long, 
                                aes(x = reorder(Country, -Between_Proportion), 
                                    y = Between_Proportion, 
                                    fill = Analysis_Type)) +
  geom_bar(stat = "identity", position = position_dodge()) +
  geom_text(aes(label = ifelse(Significant, "*", "")), 
            position = position_dodge(width = 0.9), vjust = -0.5) +
  geom_hline(yintercept = 1/3, linetype = "dashed", color = "red") +
  labs(title = "Proportion of Questions where Reasonable is Between Average and Ideal",
       subtitle = "Comparison of Mean vs Median Analysis by Country, Red line = Chance level (1/3), * = p < 0.05",
       x = "Country",
       y = "Proportion") +
  scale_y_continuous(labels = scales::percent) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

print(between_comparison_plot)
ggsave("between_proportions_comparison.png", between_comparison_plot, width = 12, height = 6, dpi = 300)

# Save the results
analysis_8_results <- list(
  country_results = country_intermediacy_results_median,
  summary = intermediacy_by_country_median,
  comparison_with_means = comparison_intermediacy_mean_median
)
```



